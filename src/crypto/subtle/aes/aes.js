
/**
 * Creates a new AesKeyGenParams object.
 * 
 * @private
 * @constructs AesKeyGenParams
 * @extends Algorithm
 * @returns {AesKeyGenParams} ewly created AesKeyGenParams object.
 */
function AesKeyGenParams() {
  
  /**
   * The length, in bits, of the key.
   * 
   * @type {number}
   */
  this.length;
}
extend(Algorithm, AesKeyGenParams);

/**
 * Initializes this algorithm with the values given as paramter.
 * 
 * @private
 * @param {object} alg The values which should be used to intitialize
 * the algorithm.
 * @returns {RsaKeyGenParams} The initialized AesKeyGenParams
 */
AesKeyGenParams.prototype.init = function(alg) {
  // Call parent init funtion
  AesKeyGenParams._super.init.call(this, alg);
  
  if(!isNumber(alg.length)) {
   throw new TypeError('AesKeyGenParams: length: Missing or not ' 
            + 'a number'); 
  }
  this.length = alg.length;
  return this;
};



/**
 * Returns a newly generated AES CryptoKey.<br />
 * The CryptoKey is generated by using a fallback library.<br />
 * AES-GCM: @see {@link http://www.w3.org/TR/WebCryptoAPI/#aes-gcm-operations}
 * 
 * @private
 * @param {Object} normAlgo The key generation function to use.
 * @param {boolean} extractable Indicating if the key can be extracted from 
 * the CryptoKey object at a later stage.
 * @param {String[]} keyUsages Indicating what can be done with the newly 
 * generated key.
 * @returns {Object} A newly generated AES CryptoKey
 */
function generateKey_AES(normAlgo, extractable, keyUsages) {
  
  if(arrayContainsOther(
          keyUsages, ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'])) {
    throw new SyntaxError('Cannot create a key using the specified ' 
              + 'key usages.');
  }
  if(normAlgo.length !== 128 
          && normAlgo.length !== 192 
          && normAlgo.length !== 256) {
    throw new OperationError('AES key length must be 128, 192 or 256 bits');
  }
  var key;
  try {
    var randoms = new Uint8Array(normAlgo.length / 8);
    getRandomValues(randoms);
    var algorithm = {
      name: normAlgo.name,
      length: normAlgo.length
    };
    key = new CryptoKey(
            'secret',
            extractable,
            algorithm,
            keyUsages,
            randoms.buffer);
  } catch(err) {
    throw new OperationError(err);
  }
  return key;
}

/**
 * Returns the AES key in the requested format.<br />
 * AES-GCM: {@link http://www.w3.org/TR/WebCryptoAPI/#aes-gcm-operations}<br />
 * 
 * @private
 * @param {string} format The data format in which the key has to be exported.
 * @param {CryptoKey} key The AES CryptoKey to export.
 * @returns {*} The AES key in the requested format.
 */
function exportKey_AES(format, key) {
  var result;
  if(format === 'jwk') {
    var jwk = {};
    jwk.kty = "oct";
    jwk.k = bytesToBase64URL(new Uint8Array(key._handle));
    jwk.alg = algorithmToJWA(key.algorithm);
    jwk.key_ops = key.usages;
    jwk.ext = key.extractable;
    result = jwk;
    
  } else if (format === 'raw') {
    var data = key._handle;
    if(!isBufferSource(data)) {
      throw new OperationError('Invalid key format.');
    }
    if(data instanceof ArrayBuffer) {
      result = data;
    } else {
      result = data.buffer;
    }
  } else {
    throw new NotSupportedError('Format "' + format + '" not supported');
  }
  return result;
}

/**
 * Returns the AES CryptoKey generated from the data given in
 * parameters.<br />
 * AES-GCM: {@link http://www.w3.org/TR/WebCryptoAPI/#aes-gcm-operations}
 * 
 * @private
 * @param {string} format the data format of the key to imported. Possible
 * values are "raw" (usually a secret key), "pkcs8" (private key), 
 * "skpi" (usually a public key) and "jwk".
 * @param {BufferSource | Object} keyData The key in the specified format.
 * @param {Object} normAlgo The normalized cryptographic algorithm for use 
 * with the output key object.
 * @param {boolean} extractable indicating if the key can be extracted from the 
 * CryptoKey object at a later stage.
 * @param {string[]} usages Indicating what can be done with the key.
 * @returns {CryptoKey} The generated AES CryptoKey.
 */
function importKey_AES(format, keyData, normAlgo, extractable, usages) {
  
  if(arrayContainsOther(
          usages, ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'])) {
    throw new SyntaxError(
            'Cannot create a key using the specified key usages.');
  }
  
  var data;
  if(format === 'raw') {
    if(!isBufferSource(keyData)) {
      throw new DataError(
              'Key data must be a BufferSource for non-JWK formats');
    }
    data = getBuffer(keyData);
    if(data.byteLength !== 128 / 8
            && data.byteLength !== 192 / 8
            && data.byteLength !== 256 / 8) {
      throw new DataError('AES key data must be 128, 192 or 256 bits');
    }
    
  } else if(format === 'jwk') {
    var jwk = keyData;
    if(jwk.kty !== 'oct') {
      throw new DataError('The JWK "kty" member was not "oct"');
    }
    if(!jwk.k) {
      throw new DataError('JWK does not meet the requirements');
    }
    data = base64URLToBytes(jwk.k).buffer;
    if(jwk.alg) {
      var algo = jwaToAlgorithm(jwk.alg);
      if(algo.length !== data.byteLength * 8) {
        throw new DataError('The JWK "alg" member was inconsistent with ' 
                + 'that specified by the Web Crypto call');
      }
      
    }
    if(jwk.use && jwk.use !== 'enc') {
      throw new DataError('The JWK "use" member was not "enc"');
    }
    if(jwk.key_ops && arrayContainsOther(usages, jwk.key_ops)) {
      throw new DataError('The JWK "key_ops" member does not contain all ' 
              + 'of the specified usages values.');
    }
    if(jwk.ext !== undefined && jwk.ext === false && extractable) {
      throw new DataError('The JWK "ext" member was inconsistent with ' 
                + 'that specified by the Web Crypto call');
    }
  } else {
    throw new NotSupportedError('Format "' + format + '" not supported');
  }
  var algorithm = {
    name: normAlgo.name,
    length: data.byteLength * 8
  };
  return new CryptoKey('secret', false, algorithm, [], data);
}

/**
 * Returns the length, in bits, of the key.
 * 
 * @private
 * @param {AesKeyGenParams} normAlgo The normalized algirithm
 * @returns {number} The length, in bits, of the key.
 */
function getKeyLength_AES(normAlgo) {
  if(normAlgo.length !== 128 
          && normAlgo.length === 192 
          && normAlgo.length === 256) {
    throw new OperationError('Invalid key length. Must be 128, 192 or 256');
  }
  return normAlgo.length;
}