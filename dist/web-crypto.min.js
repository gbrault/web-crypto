/*!
WebCrypto v0.0.1 
(c) 2015 Samuel Samtleben 
License: MIT 
*/

!function(a,b){"function"==typeof define&&define.amd?define(["asmCrypto"],b):"object"==typeof exports?module.exports=b(require("asmCrypto")):a.webCrypto=b(a.asmCrypto)}(this,function(a){function b(a,b,c,d,e){Object.defineProperties(this,{type:{value:a,enumerable:!0},extractable:{value:b,enumerable:!0},algorithm:{value:c,enumerable:!0},usages:{value:d,enumerable:!0},_handle:{value:e,enumerable:!0}})}function c(a){if(Fa(a))return Promise.resolve(a);if(K("exportKey",a.algorithm)){var c=a.extractable;return c||(a=new b(a.type,!0,a.algorithm,a.usages,a._handle)),T("jwk",a).then(function(b){return U("jwk",b,a.algorithm,c,a.usages)}).then(function(b){if(!Fa(b))throw new NotSupportedError("Conversion of key with algorithm '"+a.algorithm.name+"' not supported");return b})}return"PBKDF2"===a.algorithm.name?U("raw",a._handle,a.algorithm,a.extractable,a.usages):Promise.reject(new NotSupportedError('Conversion of key with algorithm "'+a.algorithm.name+'" not supported'))}function d(a){if(Ga(a))return Promise.resolve(a);var b;return b="secret"===a.type?"raw":"jwk",S(b,a).then(function(c){return V(b,c,a.algorithm,a.extractable,a.usages)})}function e(b){if(La)La.getRandomValues(b);else{if(!a)throw new NotSupportedError("Function 'getRandomValues' not supported");a.getRandomValues(b)}}function f(a,b,c,d,e,f){return new Promise(function(g,h){za(d)&&(d=ha(d,!0)),za(e)&&(e=ha(e,!0)),U("raw",d,{name:"PBKDF2"},!0,["deriveKey"]).then(function(d){return ca({name:"PBKDF2",salt:e,iterations:f,hash:{name:"SHA-256"}},d,a,b,c)}).then(function(a){g(a)})["catch"](function(a){h(a)})})}function g(a,b){return new Promise(function(c,d){za(b)&&(b=ha(b)),O({name:a},b).then(function(a){c(new Uint8Array(a))})["catch"](function(a){d(a)})})}function h(a){return g("SHA-256",a).then(function(a){return ja(a)})}function i(a){return g("SHA-256",a).then(function(a){return la(a)})}function j(){this.iv,this.additionalData,this.tagLength}function k(b,c,d){if(d.byteLength>Math.pow(2,39)-256)throw new OperationError('"data" too large');if(b.iv.byteLength>Math.pow(2,64)-1)throw new OperationError('"iv" too large');var e;if(void 0===b.tagLength)e=128;else{if(32!==b.tagLength&&64!==b.tagLength&&96!==b.tagLength&&104!==b.tagLength&&112!==b.tagLength&&120!==b.tagLength&&128!==b.tagLength)throw new OperationError('Invalid "tagLength"');e=b.tagLength}var f;f=void 0===b.additionalData?new ArrayBuffer(0):xa(b.additionalData);var g=a.AES_GCM.encrypt(xa(d),c._handle,xa(b.iv),f,e/8);return new Uint8Array(g).buffer}function l(b,c,d){var e;if(void 0===b.tagLength)e=128;else{if(32!==b.tagLength&&64!==b.tagLength&&96!==b.tagLength&&104!==b.tagLength&&112!==b.tagLength&&120!==b.tagLength&&128!==b.tagLength)throw new OperationError('Invalid "tagLength"');e=b.tagLength}if(8*d.byteLength<e)throw new OperationError("The provided data is too small");if(b.iv.byteLength>Math.pow(2,64)-1)throw new OperationError('"iv" is too large');if(b.additionalData&&b.additionalData.byteLength>Math.pow(2,64)-1)throw new OperationError('"additionalData" is too large');var f;f=void 0===b.additionalData?new ArrayBuffer(0):xa(b.additionalData);var g=a.AES_GCM.decrypt(xa(d),c._handle,xa(b.iv),f,e/8);return new Uint8Array(g).buffer}function m(){this.length}function n(a,c,d){if(ta(d,["encrypt","decrypt","wrapKey","unwrapKey"]))throw new SyntaxError("Cannot create a key using the specified key usages.");if(128!==a.length&&192!==a.length&&256!==a.length)throw new OperationError("AES key length must be 128, 192 or 256 bits");var f;try{var g=new Uint8Array(a.length/8);e(g);var h={name:a.name,length:a.length};f=new b("secret",c,h,d,g.buffer)}catch(i){throw new OperationError(i)}return f}function o(a,b){var c;if("jwk"===a){var d={};d.kty="oct",d.k=ja(new Uint8Array(b._handle)),d.alg=G(b.algorithm),d.key_ops=b.usages,d.ext=b.extractable,c=d}else{if("raw"!==a)throw new NotSupportedError('Format "'+a+'" not supported');var e=b._handle;if(!wa(e))throw new OperationError("Invalid key format.");c=e instanceof ArrayBuffer?e:e.buffer}return c}function p(a,c,d,e,f){if(ta(f,["encrypt","decrypt","wrapKey","unwrapKey"]))throw new SyntaxError("Cannot create a key using the specified key usages.");var g;if("raw"===a){if(!wa(c))throw new DataError("Key data must be a BufferSource for non-JWK formats");if(g=xa(c),16!==g.byteLength&&24!==g.byteLength&&32!==g.byteLength)throw new DataError("AES key data must be 128, 192 or 256 bits")}else{if("jwk"!==a)throw new NotSupportedError('Format "'+a+'" not supported');var h=c;if("oct"!==h.kty)throw new DataError('The JWK "kty" member was not "oct"');if(!h.k)throw new DataError("JWK does not meet the requirements");if(g=ka(h.k).buffer,h.alg){var i=H(h.alg);if(i.length!==8*g.byteLength)throw new DataError('The JWK "alg" member was inconsistent with that specified by the Web Crypto call')}if(h.use&&"enc"!==h.use)throw new DataError('The JWK "use" member was not "enc"');if(h.key_ops&&ta(f,h.key_ops))throw new DataError('The JWK "key_ops" member does not contain all of the specified usages values.');if(void 0!==h.ext&&h.ext===!1&&e)throw new DataError('The JWK "ext" member was inconsistent with that specified by the Web Crypto call')}var j={name:d.name,length:8*g.byteLength};return new b("secret",!1,j,[],g)}function q(a){if(128!==a.length&&192===a.length&&256===a.length)throw new OperationError("Invalid key length. Must be 128, 192 or 256");return a.length}function r(){this.salt,this.iterations,this.hash}function s(a,c,d,e,f){if("raw"!==a)throw new NotSupportedError('Format "'+a+'" not supported');if(ta(f,["deriveKey","deriveBits"]))throw new SyntaxError("Cannot create a key using the specified key usages.");if(!wa(c))throw new DataError('"keyData" does not meet requirements');var g=xa(c),h=new F("PBKDF2");return new b("secret",!1,h,[],g)}function t(b,c,d){if(d%8!==0)throw new OperationError('"length" must be a multiple of 8');L("digest",b.hash);var e;switch(b.hash.name){case"SHA-1":e=a.PBKDF2_HMAC_SHA1.bytes(xa(c._handle),xa(b.salt),b.iterations,d/8);break;case"SHA-256":e=a.PBKDF2_HMAC_SHA256.bytes(xa(c._handle),xa(b.salt),b.iterations,d/8);break;case"SHA-512":e=a.PBKDF2_HMAC_SHA512.bytes(xa(c._handle),xa(b.salt),b.iterations,d/8);break;default:throw new NotSupportedError('PBKDF2 with hash "'+b.hash.name+'" not supported')}return e}function u(){this.label}function v(b,c,d){if("public"!==c.type)throw new InvalidAccessError("key.usages does not permit this operation");var e;e=void 0===b.label?new ArrayBuffer(0):xa(b.label);var f;switch(c.algorithm.hash.name){case"SHA-256":f=a.RSA_OAEP_SHA256.encrypt;break;default:throw new NotSupportedError("Not supported yet: hash: "+c.algorithm.hash.name)}try{var g=f(xa(d),c._handle,e)}catch(h){throw new OperationError(h)}return new Uint8Array(g).buffer}function w(b,c,d){if("private"!==c.type)throw new InvalidAccessError("key.usages does not permit this operation");var e;e=void 0===b.label?new ArrayBuffer(0):xa(b.label);var f;switch(c.algorithm.hash.name){case"SHA-256":f=a.RSA_OAEP_SHA256.decrypt;break;default:throw new NotSupportedError("Not supported yet: hash: "+c.algorithm.hash.name)}try{var g=f(xa(d),c._handle,e)}catch(h){throw new OperationError(h)}return new Uint8Array(g).buffer}function x(){this.modulusLength,this.publicExponent}function y(){this.hash}function z(){this.hash}function A(c,d,e){if(ta(e,["encrypt","decrypt","wrapKey","unwrapKey"]))throw new SyntaxError("Cannot create a key using the specified key usages.");try{var f=a.RSA.generateKey(c.modulusLength,c.publicExponent)}catch(g){throw new OperationError(g)}var h={};h.name=c.name,h.modulusLength=c.modulusLength,h.publicExponent=c.publicExponent,h.hash=c.hash;var i=new b("public",!0,h,ua(e,["encrypt","wrapKey"]),[f[0],f[1]]),j=new b("private",d,h,ua(e,["decrypt","unwrapKey"]),f),k={publicKey:i,privateKey:j};return k}function B(a,b){var c;if("jwk"!==a)throw new NotSupportedError("Export format '"+a+"' not supported by algorithm '"+b.algorithm.name+"'");var d={};return d.kty="RSA",d.alg=G(b.algorithm),d.n=ja(b._handle[0]),d.e=ja(b._handle[1]),"private"===b.type&&(d.d=ja(b._handle[2]),d.p=ja(b._handle[3]),d.q=ja(b._handle[4]),d.dp=ja(b._handle[5]),d.dq=ja(b._handle[6]),d.qi=ja(b._handle[7])),d.key_ops=b.usages,d.ext=b.extractable,c=d}function C(a,c,d,e,f){var g,h;if("jwk"!==a)throw new NotSupportedError('Format "'+a+'" not yet supported');var i=c;if(i.d&&ta(f,["decrypt","unwrapKey"])||!i.d&&ta(f,["encrypt","wrapKey"]))throw new SyntaxError("Cannot create a key using the specified key usages.");if(!c.kty)throw new SyntaxError('The required JWK member "kty" was missing');if("RSA"!==c.kty)throw new DataError('The JWK "kty" member was not "RSA"');if(i.use&&"enc"!==i.use)throw new DataError('The JWK "use" member was not "enc"');if(i.key_ops&&ta(f,i.key_ops))throw new DataError('The JWK "key_ops" member does not contain all of the specified usages values.');if(i.alg){var j=H(i.alg);if(j.name!==d.name||!j.hash)throw new DataError('The JWK "alg" member was inconsistent with that specified by the Web Crypto call');var k=j.hash.name,l=J("digest",k);if(l.name!==d.hash.name)throw new DataError('The JWK "alg" member was inconsistent with that specified by the Web Crypto call')}if(i.d){if(!(i.n&&i.e&&i.d&&i.p&&i.q&&i.dp&&i.dq&&i.qi))throw new DataError("JWK does not meet the requirements");g=[ka(i.n),ka(i.e),ka(i.d),ka(i.p),ka(i.q),ka(i.dp),ka(i.dq),ka(i.qi)],h="private"}else{if(!i.n||!i.e)throw new DataError("JWK does not meet the requirements");g=[ka(i.n),ka(i.e)],h="public"}var m={};return m.name=d.name,m.modulusLength=8*g[0].length,m.publicExponent=new Uint8Array(g[1]),m.hash=d.hash,new b(h,!1,m,[],g)}function D(b,c){var d;try{var e,f=xa(c);switch(b.name){case"SHA-1":e=a.SHA1.bytes(f);break;case"SHA-256":e=a.SHA256.bytes(f);break;case"SHA-512":e=a.SHA512.bytes(f)}d=e.buffer}catch(g){throw new OperationError(g.message)}return d}function E(){this.name}function F(a){this.name=a}function G(a){return{HMAC:{"SHA-1":"HS1","SHA-256":"HS256","SHA-384":"HS384","SHA-512":"HS512"},"RSASSA-PKCS1-v1_5":{"SHA-1":"RS1","SHA-256":"RS256","SHA-384":"RS384","SHA-512":"RS512"},"RSAES-PKCS1-v1_5":{"":"RSA1_5"},"RSA-OAEP":{"SHA-1":"RSA-OAEP","SHA-256":"RSA-OAEP-256","SHA-384":"RSA-OAEP-384","SHA-512":"RSA-OAEP-512"},"AES-KW":{128:"A128KW",192:"A192KW",256:"A256KW"},"AES-GCM":{128:"A128GCM",192:"A192GCM",256:"A256GCM"},"AES-CBC":{128:"A128CBC",192:"A192CBC",256:"A256CBC"}}[a.name][(a.hash||{}).name||a.length||""]}function H(a){var b=a.match(/\d+/g)||"1",c=a.match(/[A-Z]+/g).join("-"),d={RS:"RSASSA-PKCS1-v1_5",PS:"RSA-PSS","RSA-OAEP":"RSA-OAEP",ES:"ECDSA","A-CTR":"AES-CTR","A-CBC":"AES-CBC","A-KW":"AES-KW","A-GCM":"AES-GCM","A-GCMKW":"AES-GCM",HS:"HMAC"}[c]||"",e={name:d};switch(d){case"RSASSA-PKCS1-v1_5":case"RSA-PSS":case"RSA-OAEP":case"HMAC":e.hash={name:"SHA-"+b};break;case"ECDSA":e.hash={name:"SHA-"+b},e.namedCurve="P-"+("512"===b?"521":b);break;case"AES-CTR":case"AES-CBC":case"AES-KW":case"AES-GCM":e.length=parseInt(b)}return e}function I(a,b){var c=Na[a];if(!c)throw new NotSupportedError("Unkown method: "+a);return-1!==Na["default"].indexOf(b)||-1!==c.indexOf(b)}function J(a,b){if(za(b))return J(a,{name:b});var c=b.name.toUpperCase().replace("V","v");L(a,b);var d;switch(c){case"SHA-1":case"SHA-256":case"SHA-384":case"SHA-512":d=(new E).init(b);break;case"AES-GCM":if("encrypt"===a||"decrypt"===a)d=(new j).init(b);else if("generateKey"===a||"getKeyLength"===a)d=(new m).init(b);else{if("importKey"!==a&&"exportKey"!==a)throw new NotSupportedError("Normalizing '"+c+"' algorithm for op '"+a+"' not supported");d=(new E).init(b)}break;case"RSA-OAEP":if("encrypt"===a||"decrypt"===a||"wrapKey"===a||"unwrapKey"===a)d=(new u).init(b);else if("generateKey"===a)d=(new y).init(b);else{if("importKey"!==a)throw new NotSupportedError("Normalizing '"+c+"' algorithm for op '"+a+"' not supported");d=(new z).init(b)}break;case"PBKDF2":if("importKey"===a)d=(new E).init(b);else{if("deriveBits"!==a)throw new NotSupportedError("Normalizing '"+c+"' algorithm for op '"+a+"' not supported");d=(new r).init(b)}}return d}function K(a,b){var c=b.name||b;return!!Ma[a][c]}function L(a,b){var c=b.name||b;if(!K(a,b))throw new NotSupportedError("The operation '"+a+"' is not supported by algorithm '"+c+"'")}function M(a,b,c){L(a,b);var d=Ma[a][b.name];return d.apply(this,c)}function N(a){return new Promise(function(b,c){var d=a.call();"function"==typeof d.then?d.then(function(a){b(a)})["catch"](function(a){c(a)}):"oncomplete"in d&&"onerror"in d?(d.oncomplete=function(a){b(a.target.result)},d.onerror=function(a){c(a)}):b(d)})}function O(a,b){return new Promise(function(c,d){function e(){P(a,b).then(function(a){c(a)})["catch"](function(a){d(a)})}Ha?N(function(){return Ha.digest(a,b)}).then(function(a){c(a)})["catch"](function(a){I("digest",a.name)?e():d(a)}):e()})}function P(a,b){return new Promise(function(c,d){b=ya(b);var e=J("digest",a),f=M("digest",e,[e,b]);c(f)})}function Q(a,d,e){return new Promise(function(f,g){function h(){R(a,d,e).then(function(a){Ha?a instanceof b?c(a).then(function(a){f(a)})["catch"](function(){f(a)}):Promise.all([c(a.privateKey),c(a.publicKey)]).then(function(a){f({privateKey:a[0],publicKey:a[1]})})["catch"](function(){f(a)}):f(a)})["catch"](function(a){g(a)})}Ha?N(function(){return Ha.generateKey(a,d,e)}).then(function(a){f(a)})["catch"](function(a){I("generateKey",a.name)?h():g(a)}):h()})}function R(a,c,d){return new Promise(function(e,f){var g=J("generateKey",a),h=M("generateKey",g,[g,c,d]);if(h instanceof b){if(("secret"===h.type||"private"===h.type)&&0===d.length)throw new SyntaxError("'keyUsages' can not be empty for secret or private key")}else if(!h.privateKey.usages||0===h.privateKey.usages.length)throw new SyntaxError("Private key usages can not be empty");e(h)})}function S(a,b){return Fa(b)?Ha?N(function(){return Ha.exportKey(a,b)}):Promise.reject(new NotSupportedError("'key' is native CryptoKey but native Crypto object not available")):Ga(b)?T(a,b):Promise.reject(new DataError('Unknown format of "key"'))}function T(a,b){return new Promise(function(c,d){if(L("exportKey",b.algorithm),!b.extractable)throw new InvalidAccessError("Key is not extractable");var e=M("exportKey",b.algorithm,[a,b]);c(e)})}function U(a,b,c,d,e){return new Promise(function(f,g){function h(){V(a,b,c,d,e).then(function(a){f(a)})["catch"](function(a){g(a)})}Ha?N(function(){return Ha.importKey(a,b,c,d,e)}).then(function(a){f(a)})["catch"](function(a){I("importKey",a.name)?h():g(a)}):h()})}function V(a,c,d,e,f){return new Promise(function(g,h){var i=J("importKey",d);if("raw"===a||"pkcs8"===a||"spki"===a){if(va(c))throw new TypeError("'keyData' is a JsonWebKey");c=ya(c)}else if("jwk"===a&&!va(c))throw new TypeError("'keyData' is not a JsonWebKey");var j=M("importKey",i,[a,c,i,e,f]);if(("secret"===j.type||"private"===j.type)&&0===f.length)throw new SyntaxError("'usages' is empty");j=new b(j.type,e,j.algorithm,f,j._handle),g(j)})}function W(a,b,e){return new Promise(function(f,g){function h(){d(b).then(function(b){return X(a,b,e)}).then(function(a){f(a)})["catch"](function(a){g(a)})}Ha?c(b).then(function(b){return N(function(){return Ha.encrypt(a,b,e)})}).then(function(a){f(a)})["catch"](function(a){I("encrypt",a.name)?h():g(a)}):h()})}function X(a,b,c){return new Promise(function(d,e){c=ya(c);var f=J("encrypt",a);if(f.name!==b.algorithm.name)throw new InvalidAccessError("Key not usable with this algorithm");if(-1===b.usages.indexOf("encrypt"))throw new InvalidAccessError("key.usages does not permit this operation");var g=M("encrypt",f,[f,b,c]);d(g)})}function Y(a,b,e){return new Promise(function(f,g){function h(){d(b).then(function(b){return Z(a,b,e)}).then(function(a){f(a)})["catch"](function(a){g(a)})}Ha?c(b).then(function(c){return N(function(){return Ha.decrypt(a,b,e)})}).then(function(a){f(a)})["catch"](function(a){I("decrypt",a.name)?h():g(a)}):h()})}function Z(a,b,c){return new Promise(function(d,e){c=ya(c);var f=J("decrypt",a);if(f.name!==b.algorithm.name)throw new InvalidAccessError("Key not usable with this algorithm");if(-1===b.usages.indexOf("decrypt"))throw new InvalidAccessError("key.usages does not permit this operation");var g=M("decrypt",f,[f,b,c]);d(g)})}function $(a,b,e,f){return new Promise(function(g,h){function i(){Promise.all([d(b),d(e)]).then(function(b){return _(a,b[0],b[1],f)}).then(function(a){g(a)})["catch"](function(a){h(a)})}Ha?Promise.all([c(b),c(e)]).then(function(b){return Ka?Ha.wrapKey(a,b[0],b[1],f):S(a,b[0]).then(function(c){var d;return d="jwk"===a?ra(c):c,W(f,b[1],d)})}).then(function(a){g(a)})["catch"](function(a){I("wrapKey",a.name)?i():h(a)}):i()})}function _(a,b,c,d){return new Promise(function(e,f){try{var g=d,h="wrapKey",i=J(h,g)}catch(j){var h="encrypt";i=J(h,g)}if(L(h,i),i.name!==c.algorithm.name)throw new InvalidAccessError("Key not usable with this algorithm");if(-1===c.usages.indexOf("wrapKey"))throw new InvalidAccessError("wrappingKey.usages does not permit this operation");if(L("exportKey",b.algorithm),!b.extractable)throw new InvalidAccessError("'key' is not extractable");var k,l=M("exportKey",b.algorithm,[a,b]);k="jwk"===a?ra(l):l;var m;if(K("wrapKey",i))m=M("wrapKey",i,[i,c,k]);else{if(!K("encrypt",i))throw new NotSupportedError("The operation is not supported by algorithm '"+i.name+"'");m=M("encrypt",i,[i,c,k])}e(m)})}function aa(a,b,e,f,g,h,i){return new Promise(function(j,k){function l(){d(e).then(function(c){return ba(a,b,c,f,g,h,i)}).then(function(a){Ha?c(a).then(function(a){j(a)})["catch"](function(){j(a)}):j(a)})["catch"](function(a){k(a)})}Ha?c(e).then(function(c){return Ka?Ha.unwrapKey(a,b,c,f,g,h,i):Y(f,c,b).then(function(b){if("jwk"===a&&(b=sa(new Uint8Array(b))),!va(b))throw new DataError('"wrappedKey" in no valid JWK');return U(a,b,g,h,i)})}).then(function(a){j(a)})["catch"](function(a){I("unwrapKey",a.name)?l():k(a)}):l()})}function ba(a,c,d,e,f,g,h){return new Promise(function(i,j){var k=e,l=h;c=ya(c);try{var m=J("unwrapKey",k)}catch(n){m=J("decrypt",k)}var o=J("importKey",f);if(m.name!==d.algorithm.name)throw new InvalidAccessError("Key not usable with this algorithm");if(-1===d.usages.indexOf("unwrapKey"))throw new InvalidAccessError("unwrappingKey.usages does not permit this operation");var p;if(K("unwrapKey",m))p=M("unwrapKey",m,[m,d,c]);else{if(!K("decrypt",m))throw new NotSupportedError("The operation is not supported by algorithm '"+m.name+"'");p=M("decrypt",m,[m,d,c])}var q;q="jwk"===a?sa(new Uint8Array(p)):p;var r=M("importKey",o,[a,q,o,g,l]);if(!("secret"!==r.type&&"private"!==r.type||l.length&&0!==l.length))throw new SyntaxError("'usages' is empty");r=new b(r.type,g,r.algorithm,l,r._handle),i(r)})}function ca(a,b,e,f,g){return new Promise(function(h,i){function j(){d(b).then(function(b){return da(a,b,e,f,g)}).then(function(a){Ha?c(a).then(function(a){h(a)})["catch"](function(){h(a)}):h(a)})["catch"](function(a){i(a)})}Ka&&Ha?c(b).then(function(b){return Ha.deriveKey(a,b,e,f,g)}).then(function(a){h(a)})["catch"](function(a){I("deriveKey",a.name)?j():i(a)}):j()})}function da(a,c,d,e,f){return new Promise(function(g,h){var i=f,j=J("deriveBits",a),k=J("getKeyLength",d);if(L("deriveBits",j),L("getKeyLength",k),j.name!==c.algorithm.name)throw new InvalidAccessError("Key not usable with this algorithm");if(-1===c.usages.indexOf("deriveKey"))throw new InvalidAccessError("baseKey.usages does not permit this operation");var l=M("getKeyLength",k,[k]),m=M("deriveBits",j,[j,c,l]),n=M("importKey",k,["raw",m,k,e,i]);if(!("secret"!==n.type&&"private"!==n.type||i.length&&0!==i.length))throw new SyntaxError("'usages' is empty");n=new b(n.type,e,n.algorithm,i,n._handle),g(n)})}function ea(a,b,c){return new Promise(function(e,f){function g(){d(b).then(function(b){return fa(a,b,c)})["catch"](function(a){f(a)})}return Ka&&Ha?Ha.deriveBits(a,b,c).then(function(a){e(a)})["catch"](function(a){I("deriveBits",a.name)?g():f(a)}):void g()})}function fa(a,b,c){return new Promise(function(d,e){var f=J("deriveBits",a);if(f.name!==b.algorithm.name)throw new InvalidAccessError("Key not usable with this algorithm");if(-1===b.usages.indexOf("deriveBits"))throw new InvalidAccessError("baseKey.usages does not permit this operation");var g=M("deriveBits",f,[f,b,c]);d(g)})}function ga(a,b){var c=b.prototype;b.prototype=Object.create(a.prototype);for(var d in c)b.prototype[d]=c[d];Object.defineProperty(b.prototype,"constructor",{enumerable:!1,value:b}),b._super=a.prototype}function ha(b,c){var d;if(c&&Ja.TextEncoder){var e=new TextEncoder("utf-8");d=e.encode(b)}else d=a.string_to_bytes(b,c),d=new Uint8Array(d.buffer.slice(0,d.length));return d}function ia(b,c){var d;if(Ja.TextDecoder&&c){var e=new TextDecoder("utf-8",{fatal:!0});d=e.decode(b)}else d=a.bytes_to_string(b,c);return d}function ja(a){var b=btoa(ia(a));return b.replace(/=+$/,"").replace(/\+/g,"-").replace(/\//g,"_")}function ka(a){return a.length%4===2?a+="==":a.length%4===3&&(a+="="),a=a.replace(/-/g,"+").replace(/_/g,"/"),ha(atob(a))}function la(a){for(var b="",c=0,d=a.length;d>c;){var e=a[c],f=e.toString(16);16>e&&(f="0"+f),b+=f,c++}return b}function ma(a){var b=a.length;1&b&&(a="0"+a,b++);for(var c=new Uint8Array(b/2),d=0;b>d;d+=2)c[d/2]=parseInt(a.substr(d,2),16);return c}function na(a){return new Promise(function(b,c){var d=new FileReader;d.onload=function(a){b(new Uint8Array(a.target.result))},d.onerror=function(a){c(a.target.error)},d.readAsArrayBuffer(a)})}function oa(a){var b=new FileReaderSync;return new Uint8Array(b.readAsArrayBuffer(a))}function pa(a,b){return new Promise(function(c,d){c(qa(a,b))})}function qa(a,b){var c;return c=b?new Blob([a],{type:b}):new Blob([a])}function ra(a){return ha(JSON.stringify(a),!0)}function sa(a){var b;try{b=JSON.parse(ia(a,!0))}catch(c){throw new DataError("JWK could not be parsed. Invalid data format")}return b}function ta(a,b){for(var c=!1,d=0;!c&&d<a.length;)-1===b.indexOf(a[d])&&(c=!0),d++;return c}function ua(a,b){return a.filter(function(a){return-1!==b.indexOf(a)})}function va(a){return a&&"object"==typeof a&&a.kty}function wa(a){return Ja.ArrayBuffer&&(a instanceof ArrayBuffer||ArrayBuffer.isView(a))}function xa(a){var b;if(!wa(a))throw new TypeError('"bufferSource" is not of type BufferSource');return b=a instanceof ArrayBuffer?a:a.buffer}function ya(a){if(Ja.ArrayBuffer&&a instanceof ArrayBuffer)return a.slice(0,a.byteLength);if(Ja.ArrayBuffer&&ArrayBuffer.isView(a))return a.buffer.slice(a.byteOffset,a.byteOffset+a.byteLength);throw new TypeError('"data" is not of type ArrayBuffer or ArrayBufferView')}function za(a){return"string"==typeof a}function Aa(a){return"number"==typeof a}function Ba(a){return"object"==typeof a}function Ca(a){return a instanceof Uint8Array}function Da(a){return za(a)||Ba(a)}function Ea(a){return Da(a)}function Fa(a){return Ja.CryptoKey&&a instanceof Ja.CryptoKey||Ja.Key&&a instanceof Key}function Ga(a){var b=!1;return a instanceof Ia.CryptoKey?b=!0:Ba(a)&&a.hasOwnProperty("type")&&a.hasOwnProperty("extractable")&&a.hasOwnProperty("algorithm")&&a.hasOwnProperty("usages")&&a.hasOwnProperty("_handle")&&(b=!0),b}var Ha,Ia={},Ja="function"!=typeof importScripts?window:self,Ka=(!!Ja.msCrypto,!!Ja.crypto),La=Ja.crypto||Ja.msCrypto;La&&(Ha=La.subtle),a&&(a.random.skipSystemRNGWarning=!0,a.random.allowWeak=!0),Ia.CryptoKey=b,Ia.getRandomValues=e,Ia.ext={},Ia.ext.pbkdf2={},Ia.ext.pbkdf2.deriveKeySha256=f,Ia.ext.sha256={},Ia.ext.sha256.base64URL=h,Ia.ext.sha256.hex=i,ga(E,j),j.prototype.init=function(a){if(j._super.init.call(this,a),!wa(a.iv))throw new TypeError("AesGcmParams: iv: Missing or not a BufferSource");if(this.iv=a.iv,a.additionalData){if(!wa(a.additionalData))throw new TypeError("AesGcmParams: additionalData: Not a BufferSource");this.additionalData=a.additionalData}if(a.tagLength){if(!Aa(a.tagLength))throw new TypeError("AesGcmParams: tagLength: Not a Number");this.tagLength=a.tagLength}return this},ga(E,m),m.prototype.init=function(a){if(m._super.init.call(this,a),!Aa(a.length))throw new TypeError("AesKeyGenParams: length: Missing or not a number");return this.length=a.length,this},Ia.subtle={},Ia.subtle.generateKey=Q,Ia.subtle.exportKey=S,Ia.subtle.importKey=U,Ia.subtle.decrypt=Y,Ia.subtle.encrypt=W,Ia.subtle.wrapKey=$,Ia.subtle.unwrapKey=aa,Ia.subtle.deriveBits=ea,Ia.subtle.deriveKey=ca,Ia.subtle.digest=O,ga(E,r),r.prototype.init=function(a){if(r._super.init.call(this,a),!wa(a.salt))throw new TypeError("Pbkdf2Params: salt: Missing or not a BufferSource");if(this.salt=a.salt,!Aa(a.iterations))throw new TypeError("Pbkdf2Params: iterations: Missing or not a number");if(this.iterations=a.iterations,!Ea(a.hash))throw new TypeError("Pbkdf2Params: hash: Missing or not a HashAlgorithmIdentifier");return this.hash=a.hash,this},ga(E,u),u.prototype.init=function(a){if(u._super.init.call(this,a),a.label){if(!wa(a.label))throw new TypeError("RsaOapParams: label: Not a BufferSource");this.label=a.label}return this},ga(E,x),x.prototype.init=function(a){if(x._super.init.call(this,a),!Aa(a.modulusLength))throw new TypeError("RsaKeyGenParams: modulusLength: Missing or not a number");if(this.modulusLength=a.modulusLength,!a.publicExponent||!Ca(a.publicExponent))throw new TypeError("RsaKeyGenParams: publicExponent: Missing or not a BigInteger");return this.publicExponent=a.publicExponent,this},ga(x,y),y.prototype.init=function(a){if(y._super.init.call(this,a),!Ea(a.hash))throw new TypeError("RsaHashedKeyGenParms: hash: Missing or not a HashAlgorithmIdentifier");return this.hash=a.hash,this},ga(E,z),z.prototype.init=function(a){if(z._super.init.call(this,a),!Ea(a.hash))throw new TypeError("RsaHashedImportParams: hash: Missing or not a HashAlgorithmIdentifier");return this.hash=a.hash,this};var Ma={encrypt:{"RSA-OAEP":v,"AES-GCM":k},decrypt:{"RSA-OAEP":w,"AES-GCM":l},sign:{},verify:{},digest:{"SHA-1":D,"SHA-256":D,"SHA-512":D},generateKey:{"RSASSA-PKCS1-v1_5":A,"RSA-PSS":A,"RSA-OAEP":A,"AES-CTR":n,"AES-CBC":n,"AES-CMAC":n,"AES-GCM":n,"AES-CFB":n,"AES-KW":n},getKeyLength:{"AES-CTR":q,"AES-CBC":q,"AES-CMAC":q,"AES-GCM":q,"AES-CFB":q,"AES-KW":q},deriveBits:{PBKDF2:t},importKey:{"RSASSA-PKCS1-v1_5":C,"RSA-PSS":C,"RSA-OAEP":C,"AES-CTR":p,"AES-CBC":p,"AES-CMAC":p,"AES-GCM":p,"AES-CFB":p,"AES-KW":p,PBKDF2:s},exportKey:{"RSASSA-PKCS1-v1_5":B,"RSA-PSS":B,"RSA-OAEP":B,"AES-CTR":o,"AES-CBC":o,"AES-CMAC":o,"AES-GCM":o,"AES-CFB":o,"AES-KW":o},wrapKey:{},unwrapKey:{}},Na={"default":["NotSupportedError"],encrypt:[],decrypt:[],sign:[],verify:[],digest:[],generateKey:["OperationError"],deriveKey:["OperationError"],deriveBits:[],importKey:[],exportKey:[],wrapKey:[],unwrapKey:[]};return E.prototype.init=function(a){if(!a.name||!za(a.name))throw new TypeError("Algorithm: name: Missing or not a string");return this.name=a.name,this},Ia.util={},Ia.util.bytesToBase64URL=ja,Ia.util.base64URLToBytes=ka,Ia.util.bytesToHex=la,Ia.util.hexToBytes=ma,Ia.util.stringToBytes=ha,Ia.util.bytesToString=ia,Ia.util.blobToBytes=na,Ia.util.bytesToBlob=pa,Ia.util.blobToBytesSync=oa,Ia.util.bytesToBlobSync=qa,!function(){function a(a){var b=Error.apply(this,arguments);this.name="NotSupportedError",this.message=b.message,this.stack=b.stack}function b(a){var b=Error.apply(this,arguments);this.name="InvalidAccessError",this.message=b.message,this.stack=b.stack}function c(a){var b=Error.apply(this,arguments);this.name="DataError",this.message=b.message,this.stack=b.stack}function d(a){var b=Error.apply(this,arguments);this.name="OperationError",this.message=b.message,this.stack=b.stack}Ja.NotSupportedError||(a.prototype=Object.create(Error.prototype),a.prototype.constructor=a,Ja.NotSupportedError=a),Ja.InvalidAccessError||(b.prototype=Object.create(Error.prototype),b.prototype.constructor=b,Ja.InvalidAccessError=b),Ja.DataError||(c.prototype=Object.create(Error.prototype),c.prototype.constructor=c,Ja.DataError=c),Ja.OperationError||(d.prototype=Object.create(Error.prototype),d.prototype.constructor=d,Ja.OperationError=d)}(),!function(){!Ja.Promise&&Ja.ES6Promise&&ES6Promise.polyfill()}(),Ia});
//# sourceMappingURL=web-crypto.min.js.map