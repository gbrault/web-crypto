/*!
WebCrypto v0.0.1 
(c) 2015 Samuel Samtleben 
License: MIT 
*/

!function(a,b){"function"==typeof define&&define.amd?define(["asmCrypto"],b):"object"==typeof exports?module.exports=b(require("asmCrypto")):a.webCrypto=b(a.asmCrypto)}(this,function(a){function b(a,b,c,d,e){Object.defineProperties(this,{type:{value:a,enumerable:!0},extractable:{value:b,enumerable:!0},algorithm:{value:c,enumerable:!0},usages:{value:d,enumerable:!0},_handle:{value:e,enumerable:!1}})}function c(a){if(xa(a))return Promise.resolve(a);if(G("exportKey",a.algorithm)){var c=a.extractable;return c||(a=new b(a.type,!0,a.algorithm,a.usages,a._handle)),P("jwk",a).then(function(b){return Q("jwk",b,a.algorithm,c,a.usages)}).then(function(b){if(!xa(b))throw new NotSupportedError("Conversion of key with algorithm '"+a.algorithm.name+"' not supported");return b})}return"PBKDF2"===a.algorithm.name?Q("raw",a._handle,a.algorithm,a.extractable,a.usages):Promise.reject(new NotSupportedError('Conversion of key with algorithm "'+a.algorithm.name+'" not supported'))}function d(a){return ya(a)?Promise.resolve(a):exporteKey("jwk",a).then(function(b){return R("jwk",b,a.algorithm,a.extractable,a.usages)})}function e(b){if(Da)Da.getRandomValues(b);else{if(!a)throw new NotSupportedError("Function 'getRandomValues' not supported");a.getRandomValues(b)}}function f(a,b,c,d,e,f){return new Promise(function(g,h){ra(d)&&(d=da(d,!0)),ra(e)&&(e=da(e,!0)),Q("raw",d,{name:"PBKDF2"},!1,["deriveKey"]).then(function(d){return $({name:"PBKDF2",salt:e,iterations:f,hash:{name:"SHA-256"}},d,a,b,c)}).then(function(a){g(a)})["catch"](function(a){h(a)})})}function g(){this.iv,this.additionalData,this.tagLength}function h(b,c,d){if(d.byteLength>Math.pow(2,39)-256)throw new OperationError('"data" too large');if(b.iv.byteLength>Math.pow(2,64)-1)throw new OperationError('"iv" too large');var e;if(void 0===b.tagLength)e=128;else{if(32!==b.tagLength&&64!==b.tagLength&&96!==b.tagLength&&104!==b.tagLength&&112!==b.tagLength&&120!==b.tagLength&&128!==b.tagLength)throw new OperationError('Invalid "tagLength"');e=b.tagLength}var f;f=void 0===b.additionalData?new ArrayBuffer(0):pa(b.additionalData);var g=a.AES_GCM.encrypt(pa(d),c._handle,pa(b.iv),f,e/8);return new Uint8Array(g).buffer}function i(b,c,d){var e;if(void 0===b.tagLength)e=128;else{if(32!==b.tagLength&&64!==b.tagLength&&96!==b.tagLength&&104!==b.tagLength&&112!==b.tagLength&&120!==b.tagLength&&128!==b.tagLength)throw new OperationError('Invalid "tagLength"');e=b.tagLength}if(8*d.byteLength<e)throw new OperationError("The provided data is too small");if(b.iv.byteLength>Math.pow(2,64)-1)throw new OperationError('"iv" is too large');if(b.additionalData&&b.additionalData.byteLength>Math.pow(2,64)-1)throw new OperationError('"additionalData" is too large');var f;f=void 0===b.additionalData?new ArrayBuffer(0):pa(b.additionalData);var g=a.AES_GCM.decrypt(pa(d),c._handle,pa(b.iv),f,e/8);return new Uint8Array(g).buffer}function j(){this.length}function k(a,c,d){if(la(d,["encrypt","decrypt","wrapKey","unwrapKey"]))throw new SyntaxError("Cannot create a key using the specified key usages.");if(128!==a.length&&192!==a.length&&256!==a.length)throw new OperationError("AES key length must be 128, 192 or 256 bits");var f;try{var g=new Uint8Array(a.length/8);e(g);var h={name:a.name,length:a.length};f=new b("secret",c,h,d,g.buffer)}catch(i){throw new OperationError(i)}return f}function l(a,b){var c;if("jwk"===a){var d={};d.kty="oct",d.k=fa(new Uint8Array(b._handle)),d.alg=D(b.algorithm),d.key_ops=b.usages,d.ext=b.extractable,c=d}else{if("raw"!==a)throw new NotSupportedError('Format "'+a+'" not supported');var e=b._handle;if(!oa(e))throw new OperationError("Invalid key format.");c=e instanceof ArrayBuffer?e:e.buffer}return c}function m(a,c,d,e,f){if(la(f,["encrypt","decrypt","wrapKey","unwrapKey"]))throw new SyntaxError("Cannot create a key using the specified key usages.");var g;if("raw"===a){if(!oa(c))throw new DataError("Key data must be a BufferSource for non-JWK formats");if(g=pa(c),16!==g.byteLength&&24!==g.byteLength&&32!==g.byteLength)throw new DataError("AES key data must be 128, 192 or 256 bits")}else{if("jwk"!==a)throw new NotSupportedError('Format "'+a+'" not supported');var h=c;if("oct"!==h.kty)throw new DataError('The JWK "kty" member was not "oct"');if(!h.k)throw new DataError("JWK does not meet the requirements");if(g=ga(h.k).buffer,h.alg){var i=E(h.alg);if(i.length!==8*g.byteLength)throw new DataError('The JWK "alg" member was inconsistent with that specified by the Web Crypto call')}if(h.use&&"enc"!==h.use)throw new DataError('The JWK "use" member was not "enc"');if(h.key_ops&&la(f,h.key_ops))throw new DataError('The JWK "key_ops" member does not contain all of the specified usages values.');if(void 0!==h.ext&&h.ext===!1&&e)throw new DataError('The JWK "ext" member was inconsistent with that specified by the Web Crypto call')}var j={name:d.name,length:8*g.byteLength};return new b("secret",!1,j,[],g)}function n(a){if(128!==a.length&&192===a.length&&256===a.length)throw new OperationError("Invalid key length. Must be 128, 192 or 256");return a.length}function o(){this.salt,this.iterations,this.hash}function p(a,c,d,e,f){if("raw"!==a)throw new NotSupportedError('Format "'+a+'" not supported');if(la(f,["deriveKey","deriveBits"]))throw new SyntaxError("Cannot create a key using the specified key usages.");if(!oa(c))throw new DataError('"keyData" does not meet requirements');var g=pa(c),h=new C("PBKDF2");return new b("secret",!1,h,[],g)}function q(b,c,d){if(d%8!==0)throw new OperationError('"length" must be a multiple of 8');H("digest",b.hash);var e;switch(b.hash.name){case"SHA-1":e=a.PBKDF2_HMAC_SHA1.bytes(pa(c._handle),pa(b.salt),b.iterations,d/8);break;case"SHA-256":e=a.PBKDF2_HMAC_SHA256.bytes(pa(c._handle),pa(b.salt),b.iterations,d/8);break;case"SHA-512":e=a.PBKDF2_HMAC_SHA512.bytes(pa(c._handle),pa(b.salt),b.iterations,d/8);break;default:throw new NotSupportedError('PBKDF2 with hash "'+b.hash.name+'" not supported')}return e}function r(){this.label}function s(b,c,d){if("public"!==c.type)throw new InvalidAccessError("key.usages does not permit this operation");var e;e=void 0===b.label?new ArrayBuffer(0):pa(b.label);var f;switch(c.algorithm.hash.name){case"SHA-256":f=a.RSA_OAEP_SHA256.encrypt;break;default:throw new NotSupportedError("Not supported yet: hash: "+c.algorithm.hash.name)}try{var g=f(pa(d),c._handle,e)}catch(h){throw new OperationError(h)}return new Uint8Array(g).buffer}function t(b,c,d){if("private"!==c.type)throw new InvalidAccessError("key.usages does not permit this operation");var e;e=void 0===b.label?new ArrayBuffer(0):pa(b.label);var f;switch(c.algorithm.hash.name){case"SHA-256":f=a.RSA_OAEP_SHA256.decrypt;break;default:throw new NotSupportedError("Not supported yet: hash: "+c.algorithm.hash.name)}try{var g=f(pa(d),c._handle,e)}catch(h){throw new OperationError(h)}return new Uint8Array(g).buffer}function u(){this.modulusLength,this.publicExponent}function v(){this.hash}function w(){this.hash}function x(c,d,e){if(la(e,["encrypt","decrypt","wrapKey","unwrapKey"]))throw new SyntaxError("Cannot create a key using the specified key usages.");try{var f=a.RSA.generateKey(c.modulusLength,c.publicExponent)}catch(g){throw new OperationError(g)}var h={};h.name=c.name,h.modulusLength=c.modulusLength,h.publicExponent=c.publicExponent,h.hash=c.hash;var i=new b("public",!0,h,ma(e,["encrypt","wrapKey"]),[f[0],f[1]]),j=new b("private",d,h,ma(e,["decrypt","unwrapKey"]),f),k={publicKey:i,privateKey:j};return k}function y(a,b){var c;if("jwk"!==a)throw new NotSupportedError("Export format '"+a+"' not supported by algorithm '"+b.algorithm.name+"'");var d={};return d.kty="RSA",d.alg=D(b.algorithm),d.n=fa(b._handle[0]),d.e=fa(b._handle[1]),"private"===b.type&&(d.d=fa(b._handle[2]),d.p=fa(b._handle[3]),d.q=fa(b._handle[4]),d.dp=fa(b._handle[5]),d.dq=fa(b._handle[6]),d.qi=fa(b._handle[7])),d.key_ops=b.usages,d.ext=b.extractable,c=d}function z(a,c,d,e,f){var g,h;if("jwk"!==a)throw new NotSupportedError('Format "'+a+'" not yet supported');var i=c;if(i.d&&la(f,["decrypt","unwrapKey"])||!i.d&&la(f,["encrypt","wrapKey"]))throw new SyntaxError("Cannot create a key using the specified key usages.");if(!c.kty)throw new SyntaxError('The required JWK member "kty" was missing');if("RSA"!==c.kty)throw new DataError('The JWK "kty" member was not "RSA"');if(i.use&&"enc"!==i.use)throw new DataError('The JWK "use" member was not "enc"');if(i.key_ops&&la(f,i.key_ops))throw new DataError('The JWK "key_ops" member does not contain all of the specified usages values.');if(i.alg){var j=E(i.alg);if(j.name!==d.name||!j.hash)throw new DataError('The JWK "alg" member was inconsistent with that specified by the Web Crypto call');var k=j.hash.name,l=F("digest",k);if(l.name!==d.hash.name)throw new DataError('The JWK "alg" member was inconsistent with that specified by the Web Crypto call')}if(i.d){if(!(i.n&&i.e&&i.d&&i.p&&i.q&&i.dp&&i.dq&&i.qi))throw new DataError("JWK does not meet the requirements");g=[ga(i.n),ga(i.e),ga(i.d),ga(i.p),ga(i.q),ga(i.dp),ga(i.dq),ga(i.qi)],h="private"}else{if(!i.n||!i.e)throw new DataError("JWK does not meet the requirements");g=[ga(i.n),ga(i.e)],h="public"}var m={};return m.name=d.name,m.modulusLength=8*g[0].length,m.publicExponent=new Uint8Array(g[1]),m.hash=d.hash,new b(h,!1,m,[],g)}function A(b,c){var d;try{var e,f=pa(c);switch(b.name){case"SHA-1":e=a.SHA1.bytes(f);break;case"SHA-256":e=a.SHA256.bytes(f);break;case"SHA-512":e=a.SHA512.bytes(f)}d=e.buffer}catch(g){throw new OperationError(g.message)}return d}function B(){this.name}function C(a){this.name=a}function D(a){return{HMAC:{"SHA-1":"HS1","SHA-256":"HS256","SHA-384":"HS384","SHA-512":"HS512"},"RSASSA-PKCS1-v1_5":{"SHA-1":"RS1","SHA-256":"RS256","SHA-384":"RS384","SHA-512":"RS512"},"RSAES-PKCS1-v1_5":{"":"RSA1_5"},"RSA-OAEP":{"SHA-1":"RSA-OAEP","SHA-256":"RSA-OAEP-256","SHA-384":"RSA-OAEP-384","SHA-512":"RSA-OAEP-512"},"AES-KW":{128:"A128KW",192:"A192KW",256:"A256KW"},"AES-GCM":{128:"A128GCM",192:"A192GCM",256:"A256GCM"},"AES-CBC":{128:"A128CBC",192:"A192CBC",256:"A256CBC"}}[a.name][(a.hash||{}).name||a.length||""]}function E(a){var b=a.match(/\d+/g)||"1",c=a.match(/[A-Z]+/g).join("-"),d={RS:"RSASSA-PKCS1-v1_5",PS:"RSA-PSS","RSA-OAEP":"RSA-OAEP",ES:"ECDSA","A-CTR":"AES-CTR","A-CBC":"AES-CBC","A-KW":"AES-KW","A-GCM":"AES-GCM","A-GCMKW":"AES-GCM",HS:"HMAC"}[c]||"",e={name:d};switch(d){case"RSASSA-PKCS1-v1_5":case"RSA-PSS":case"RSA-OAEP":case"HMAC":e.hash={name:"SHA-"+b};break;case"ECDSA":e.hash={name:"SHA-"+b},e.namedCurve="P-"+("512"===b?"521":b);break;case"AES-CTR":case"AES-CBC":case"AES-KW":case"AES-GCM":e.length=parseInt(b)}return e}function F(a,b){if(ra(b))return F(a,{name:b});var c=b.name.toUpperCase().replace("V","v");H(a,b);var d;switch(c){case"SHA-1":case"SHA-256":case"SHA-384":case"SHA-512":d=(new B).init(b);break;case"AES-GCM":if("encrypt"===a||"decrypt"===a)d=(new g).init(b);else if("generateKey"===a||"getKeyLength"===a)d=(new j).init(b);else{if("importKey"!==a&&"exportKey"!==a)throw new NotSupportedError("Normalizing '"+c+"' algorithm for op '"+a+"' not supported");d=(new B).init(b)}break;case"RSA-OAEP":if("encrypt"===a||"decrypt"===a||"wrapKey"===a||"unwrapKey"===a)d=(new r).init(b);else if("generateKey"===a)d=(new v).init(b);else{if("importKey"!==a)throw new NotSupportedError("Normalizing '"+c+"' algorithm for op '"+a+"' not supported");d=(new w).init(b)}break;case"PBKDF2":if("importKey"===a)d=(new B).init(b);else{if("deriveBits"!==a)throw new NotSupportedError("Normalizing '"+c+"' algorithm for op '"+a+"' not supported");d=(new o).init(b)}}return d}function G(a,b){var c=b.name||b;return!!Ea[a][c]}function H(a,b){var c=b.name||b;if(!G(a,b))throw new NotSupportedError("The operation '"+a+"' is not supported by algorithm '"+c+"'")}function I(a,b,c){H(a,b);var d=Ea[a][b.name];return d.apply(this,c)}function J(a){return new Promise(function(b,c){var d=a.call();"function"==typeof d.then?d.then(function(a){b(a)})["catch"](function(a){c(a)}):"oncomplete"in d&&"onerror"in d?(d.oncomplete=function(a){b(a.target.result)},d.onerror=function(a){c(a)}):b(d)})}function K(a,b){return new Promise(function(c,d){function e(){L(a,b).then(function(a){c(a)})["catch"](function(a){d(a)})}za?J(function(){return za.digest(a,b)}).then(function(a){c(a)})["catch"](function(a){"NotSupportedError"===a.name?e():d(a)}):e()})}function L(a,b){return new Promise(function(c,d){b=qa(b);var e=F("digest",a),f=I("digest",e,[e,b]);c(f)})}function M(a,d,e){return new Promise(function(f,g){function h(){N(a,d,e).then(function(a){za?a instanceof b?c(a).then(function(a){f(a)})["catch"](function(){f(a)}):Promise.all([c(a.privateKey),c(a.publicKey)]).then(function(a){f({privateKey:a[0],publicKey:a[1]})})["catch"](function(){f(a)}):f(a)})["catch"](function(a){g(a)})}za?J(function(){return za.generateKey(a,d,e)}).then(function(a){f(a)})["catch"](function(a){"NotSupportedError"===a.name||"OperationError"===a.name?h():g(a)}):h()})}function N(a,c,d){return new Promise(function(e,f){var g=F("generateKey",a),h=I("generateKey",g,[g,c,d]);if(h instanceof b){if(("secret"===h.type||"private"===h.type)&&0===d.length)throw new SyntaxError("'keyUsages' can not be empty for secret or private key")}else if(!h.privateKey.usages||0===h.privateKey.usages.length)throw new SyntaxError("Private key usages can not be empty");e(h)})}function O(a,b){return xa(b)?za?J(function(){return za.exportKey(a,b)}):Promise.reject(new NotSupportedError("'key' is native CryptoKey but native Crypto object not available")):ya(b)?P(a,b):Promise.reject(new DataError('Unknown format of "key"'))}function P(a,b){return new Promise(function(c,d){if(H("exportKey",b.algorithm),!b.extractable)throw new InvalidAccessError("Key is not extractable");var e=I("exportKey",b.algorithm,[a,b]);c(e)})}function Q(a,b,d,e,f){return new Promise(function(g,h){function i(){R(a,b,d,e,f).then(function(a){za?c(a).then(function(a){g(a)})["catch"](function(){g(a)}):g(a)})["catch"](function(a){h(a)})}za?J(function(){return za.importKey(a,b,d,e,f)}).then(function(a){g(a)})["catch"](function(a){"NotSupporedError"===a.name?i():h(a)}):i()})}function R(a,c,d,e,f){return new Promise(function(g,h){var i=F("importKey",d);if("raw"===a||"pkcs8"===a||"spki"===a){if(na(c))throw new TypeError("'keyData' is a JsonWebKey");c=qa(c)}else if("jwk"===a&&!na(c))throw new TypeError("'keyData' is not a JsonWebKey");var j=I("importKey",i,[a,c,i,e,f]);if(("secret"===j.type||"private"===j.type)&&0===f.length)throw new SyntaxError("'usages' is empty");j=new b(j.type,e,j.algorithm,f,j._handle),g(j)})}function S(a,b,e){return new Promise(function(f,g){function h(){d(b).then(function(b){return T(a,b,e)}).then(function(a){f(a)})["catch"](function(a){g(a)})}za?c(b).then(function(b){return J(function(){return za.encrypt(a,b,e)})}).then(function(a){f(a)})["catch"](function(a){"NotSupportedError"===a.name?h():g(a)}):h()})}function T(a,b,c){return new Promise(function(d,e){c=qa(c);var f=F("encrypt",a);if(f.name!==b.algorithm.name)throw new InvalidAccessError("Key not usable with this algorithm");if(-1===b.usages.indexOf("encrypt"))throw new InvalidAccessError("key.usages does not permit this operation");var g=I("encrypt",f,[f,b,c]);d(g)})}function U(a,b,e){return new Promise(function(f,g){function h(){d(b).then(function(b){return V(a,b,e)}).then(function(a){f(a)})["catch"](function(a){g(a)})}za?c(b).then(function(c){return J(function(){return za.decrypt(a,b,e)})}).then(function(a){f(a)})["catch"](function(a){"NotSupportedError"===a.name?h():g(a)}):h()})}function V(a,b,c){return new Promise(function(d,e){c=qa(c);var f=F("decrypt",a);if(f.name!==b.algorithm.name)throw new InvalidAccessError("Key not usable with this algorithm");if(-1===b.usages.indexOf("decrypt"))throw new InvalidAccessError("key.usages does not permit this operation");var g=I("decrypt",f,[f,b,c]);d(g)})}function W(a,b,e,f){return new Promise(function(g,h){function i(){Promise.all([d(b),d(e)]).then(function(b){return X(a,b[0],b[1],f)}).then(function(a){g(a)})["catch"](function(a){h(a)})}za?Promise.all([c(b),c(e)]).then(function(b){return Ca?za.wrapKey(a,b[0],b[1],f):O(a,b[0]).then(function(c){var d;return d="jwk"===a?ja(c):c,S(f,b[1],d)})}).then(function(a){g(a)})["catch"](function(a){"NotSupportedError"===a.name?i():h(a)}):i()})}function X(a,b,c,d){return new Promise(function(e,f){try{var g=d,h="wrapKey",i=F(h,g)}catch(j){var h="encrypt";i=F(h,g)}if(H(h,i),i.name!==c.algorithm.name)throw new InvalidAccessError("Key not usable with this algorithm");if(-1===c.usages.indexOf("wrapKey"))throw new InvalidAccessError("wrappingKey.usages does not permit this operation");if(H("exportKey",b.algorithm),!b.extractable)throw new InvalidAccessError("'key' is not extractable");var k,l=I("exportKey",b.algorithm,[a,b]);k="jwk"===a?ja(l):l;var m;if(G("wrapKey",i))m=I("wrapKey",i,[i,c,k]);else{if(!G("encrypt",i))throw new NotSupportedError("The operation is not supported by algorithm '"+i.name+"'");m=I("encrypt",i,[i,c,k])}e(m)})}function Y(a,b,e,f,g,h,i){return new Promise(function(j,k){function l(){d(e).then(function(c){return Z(a,b,c,f,g,h,i)}).then(function(a){za?c(a).then(function(a){j(a)})["catch"](function(){j(a)}):j(a)})["catch"](function(a){k(a)})}za?c(e).then(function(c){return Ca?za.unwrapKey(a,b,c,f,g,h,i):U(f,c,b).then(function(b){if("jwk"===a&&(b=ka(new Uint8Array(b))),!na(b))throw new DataError('"wrappedKey" in no valid JWK');return Q(a,b,g,h,i)})}).then(function(a){j(a)})["catch"](function(a){"NotSupportedError"===a.name?l():k(a)}):l()})}function Z(a,c,d,e,f,g,h){return new Promise(function(i,j){var k=e,l=h;c=qa(c);try{var m=F("unwrapKey",k)}catch(n){m=F("decrypt",k)}var o=F("importKey",f);if(m.name!==d.algorithm.name)throw new InvalidAccessError("Key not usable with this algorithm");if(-1===d.usages.indexOf("unwrapKey"))throw new InvalidAccessError("unwrappingKey.usages does not permit this operation");var p;if(G("unwrapKey",m))p=I("unwrapKey",m,[m,d,c]);else{if(!G("decrypt",m))throw new NotSupportedError("The operation is not supported by algorithm '"+m.name+"'");p=I("decrypt",m,[m,d,c])}var q;q="jwk"===a?ka(new Uint8Array(p)):p;var r=I("importKey",o,[a,q,o,g,l]);if(!("secret"!==r.type&&"private"!==r.type||l.length&&0!==l.length))throw new SyntaxError("'usages' is empty");r=new b(r.type,g,r.algorithm,l,r._handle),i(r)})}function $(a,b,e,f,g){return new Promise(function(h,i){function j(){d(b).then(function(b){return _(a,b,e,f,g)}).then(function(a){za?c(a).then(function(a){h(a)})["catch"](function(){h(a)}):h(a)})["catch"](function(a){i(a)})}Ca&&za?c(b).then(function(b){return za.deriveKey(a,b,e,f,g)}).then(function(a){h(a)})["catch"](function(a){"NotSupportedError"===a.name?j():i(a)}):j()})}function _(a,c,d,e,f){return new Promise(function(g,h){var i=f,j=F("deriveBits",a),k=F("getKeyLength",d);if(H("deriveBits",j),H("getKeyLength",k),j.name!==c.algorithm.name)throw new InvalidAccessError("Key not usable with this algorithm");if(-1===c.usages.indexOf("deriveKey"))throw new InvalidAccessError("baseKey.usages does not permit this operation");var l=I("getKeyLength",k,[k]),m=I("deriveBits",j,[j,c,l]),n=I("importKey",k,["raw",m,k,e,i]);if(!("secret"!==n.type&&"private"!==n.type||i.length&&0!==i.length))throw new SyntaxError("'usages' is empty");n=new b(n.type,e,n.algorithm,i,n._handle),g(n)})}function aa(a,b,c){return new Promise(function(e,f){function g(){d(b).then(function(b){return ba(a,b,c)})["catch"](function(a){f(a)})}return Ca&&za?za.deriveBits(a,b,c).then(function(a){e(a)})["catch"](function(a){"NotSupportedError"===a.name?g():f(a)}):void g()})}function ba(a,b,c){return new Promise(function(d,e){var f=F("deriveBits",a);if(f.name!==b.algorithm.name)throw new InvalidAccessError("Key not usable with this algorithm");if(-1===b.usages.indexOf("deriveBits"))throw new InvalidAccessError("baseKey.usages does not permit this operation");var g=I("deriveBits",f,[f,b,c]);d(g)})}function ca(a,b){var c=b.prototype;b.prototype=Object.create(a.prototype);for(var d in c)b.prototype[d]=c[d];Object.defineProperty(b.prototype,"constructor",{enumerable:!1,value:b}),b._super=a.prototype}function da(b,c){var d;if(c&&Ba.TextEncoder){var e=new TextEncoder("utf-8");d=e.encode(b)}else d=a.string_to_bytes(b,c),d=new Uint8Array(d.buffer.slice(0,d.length));return d}function ea(b,c){var d;if(Ba.TextDecoder&&c){var e=new TextDecoder("utf-8",{fatal:!0});d=e.decode(b)}else d=a.bytes_to_string(b,c);return d}function fa(a){var b=btoa(ea(a));return b.replace(/=+$/,"").replace(/\+/g,"-").replace(/\//g,"_")}function ga(a){return a.length%4===2?a+="==":a.length%4===3&&(a+="="),a=a.replace(/-/g,"+").replace(/_/g,"/"),da(atob(a))}function ha(a){for(var b="",c=0,d=a.length;d>c;){var e=a[c],f=e.toString(16);16>e&&(f="0"+f),b+=f,c++}return b}function ia(a){var b=a.length;1&b&&(a="0"+a,b++);for(var c=new Uint8Array(b/2),d=0;b>d;d+=2)c[d/2]=parseInt(a.substr(d,2),16);return c}function ja(a){return da(JSON.stringify(a),!0)}function ka(a){var b;try{b=JSON.parse(ea(a,!0))}catch(c){throw new DataError("JWK could not be parsed. Invalid data format")}return b}function la(a,b){for(var c=!1,d=0;!c&&d<a.length;)-1===b.indexOf(a[d])&&(c=!0),d++;return c}function ma(a,b){return a.filter(function(a){return-1!==b.indexOf(a)})}function na(a){return a&&"object"==typeof a&&a.kty}function oa(a){return Ba.ArrayBuffer&&(a instanceof ArrayBuffer||ArrayBuffer.isView(a))}function pa(a){var b;if(!oa(a))throw new TypeError('"bufferSource" is not of type BufferSource');return b=a instanceof ArrayBuffer?a:a.buffer}function qa(a){if(Ba.ArrayBuffer&&a instanceof ArrayBuffer)return a.slice(0,a.byteLength);if(Ba.ArrayBuffer&&ArrayBuffer.isView(a))return a.buffer.slice(a.byteOffset,a.byteOffset+a.byteLength);throw new TypeError('"data" is not of type ArrayBuffer or ArrayBufferView')}function ra(a){return"string"==typeof a}function sa(a){return"number"==typeof a}function ta(a){return"object"==typeof a}function ua(a){return a instanceof Uint8Array}function va(a){return ra(a)||ta(a)}function wa(a){return va(a)}function xa(a){return Ba.CryptoKey&&a instanceof Ba.CryptoKey||Ba.Key&&a instanceof Key}function ya(a){return a instanceof Aa.CryptoKey}var za,Aa={},Ba="function"!=typeof importScripts?window:self,Ca=(!!Ba.msCrypto,!!Ba.crypto),Da=Ba.crypto||Ba.msCrypto;Da&&(za=Da.subtle),Aa.CryptoKey=b,Aa.getRandomValues=e,Aa.ext={},Aa.ext.pbkdf2={},Aa.ext.pbkdf2.deriveKeySha256=f,ca(B,g),g.prototype.init=function(a){if(g._super.init.call(this,a),!oa(a.iv))throw new TypeError("AesGcmParams: iv: Missing or not a BufferSource");if(this.iv=a.iv,a.additionalData){if(!oa(a.additionalData))throw new TypeError("AesGcmParams: additionalData: Not a BufferSource");this.additionalData=a.additionalData}if(a.tagLength){if(!sa(a.tagLength))throw new TypeError("AesGcmParams: tagLength: Not a Number");this.tagLength=a.tagLength}return this},ca(B,j),j.prototype.init=function(a){if(j._super.init.call(this,a),!sa(a.length))throw new TypeError("AesKeyGenParams: length: Missing or not a number");return this.length=a.length,this},Aa.subtle={},Aa.subtle.generateKey=M,Aa.subtle.exportKey=O,Aa.subtle.importKey=Q,Aa.subtle.decrypt=U,Aa.subtle.encrypt=S,Aa.subtle.wrapKey=W,Aa.subtle.unwrapKey=Y,Aa.subtle.deriveBits=aa,Aa.subtle.deriveKey=$,Aa.subtle.digest=K,ca(B,o),o.prototype.init=function(a){if(o._super.init.call(this,a),!oa(a.salt))throw new TypeError("Pbkdf2Params: salt: Missing or not a BufferSource");if(this.salt=a.salt,!sa(a.iterations))throw new TypeError("Pbkdf2Params: iterations: Missing or not a number");if(this.iterations=a.iterations,!wa(a.hash))throw new TypeError("Pbkdf2Params: hash: Missing or not a HashAlgorithmIdentifier");return this.hash=a.hash,this},ca(B,r),r.prototype.init=function(a){if(r._super.init.call(this,a),a.label){if(!oa(a.label))throw new TypeError("RsaOapParams: label: Not a BufferSource");this.label=a.label}return this},ca(B,u),u.prototype.init=function(a){if(u._super.init.call(this,a),!sa(a.modulusLength))throw new TypeError("RsaKeyGenParams: modulusLength: Missing or not a number");if(this.modulusLength=a.modulusLength,!a.publicExponent||!ua(a.publicExponent))throw new TypeError("RsaKeyGenParams: publicExponent: Missing or not a BigInteger");return this.publicExponent=a.publicExponent,this},ca(u,v),v.prototype.init=function(a){if(v._super.init.call(this,a),!wa(a.hash))throw new TypeError("RsaHashedKeyGenParms: hash: Missing or not a HashAlgorithmIdentifier");return this.hash=a.hash,this},ca(B,w),w.prototype.init=function(a){if(w._super.init.call(this,a),!wa(a.hash))throw new TypeError("RsaHashedImportParams: hash: Missing or not a HashAlgorithmIdentifier");return this.hash=a.hash,this};var Ea={encrypt:{"RSA-OAEP":s,"AES-GCM":h},decrypt:{"RSA-OAEP":t,"AES-GCM":i},sign:{},verify:{},digest:{"SHA-1":A,"SHA-256":A,"SHA-512":A},generateKey:{"RSASSA-PKCS1-v1_5":x,"RSA-PSS":x,"RSA-OAEP":x,"AES-CTR":k,"AES-CBC":k,"AES-CMAC":k,"AES-GCM":k,"AES-CFB":k,"AES-KW":k},getKeyLength:{"AES-CTR":n,"AES-CBC":n,"AES-CMAC":n,"AES-GCM":n,"AES-CFB":n,"AES-KW":n},deriveBits:{PBKDF2:q},importKey:{"RSASSA-PKCS1-v1_5":z,"RSA-PSS":z,"RSA-OAEP":z,"AES-CTR":m,"AES-CBC":m,"AES-CMAC":m,"AES-GCM":m,"AES-CFB":m,"AES-KW":m,PBKDF2:p},exportKey:{"RSASSA-PKCS1-v1_5":y,"RSA-PSS":y,"RSA-OAEP":y,"AES-CTR":l,"AES-CBC":l,"AES-CMAC":l,"AES-GCM":l,"AES-CFB":l,"AES-KW":l},wrapKey:{},unwrapKey:{}};return B.prototype.init=function(a){if(!a.name||!ra(a.name))throw new TypeError("Algorithm: name: Missing or not a string");return this.name=a.name,this},Aa.util={},Aa.util.bytesToBase64URL=fa,Aa.util.base64URLToBytes=ga,Aa.util.bytesToHex=ha,Aa.util.hexToBytes=ia,!function(){function a(a){var b=Error.apply(this,arguments);this.name="NotSupportedError",this.message=b.message,this.stack=b.stack}function b(a){var b=Error.apply(this,arguments);this.name="InvalidAccessError",this.message=b.message,this.stack=b.stack}function c(a){var b=Error.apply(this,arguments);this.name="DataError",this.message=b.message,this.stack=b.stack}function d(a){var b=Error.apply(this,arguments);this.name="OperationError",this.message=b.message,this.stack=b.stack}Ba.NotSupportedError||(a.prototype=Object.create(Error.prototype),a.prototype.constructor=a,Ba.NotSupportedError=a),Ba.InvalidAccessError||(b.prototype=Object.create(Error.prototype),b.prototype.constructor=b,Ba.InvalidAccessError=b),Ba.DataError||(c.prototype=Object.create(Error.prototype),c.prototype.constructor=c,Ba.DataError=c),Ba.OperationError||(d.prototype=Object.create(Error.prototype),d.prototype.constructor=d,Ba.OperationError=d)}(),!function(){!Ba.Promise&&Ba.ES6Promise&&ES6Promise.polyfill()}(),Aa});
//# sourceMappingURL=web-crypto.min.js.map