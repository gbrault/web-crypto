<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: crypto/subtle/rsa/rsa.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: crypto/subtle/rsa/rsa.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Creates a new RsaKeyGenParms object.
 * @see {@link http://www.w3.org/TR/WebCryptoAPI/#dfn-RsaKeyGenParams}
 * 
 * @private
 * @constructs RsaKeyGenParams
 * @extends Algorithm
 * @returns {RsaKeyGenParams} Newly created RsaKeyGenParms object.
 */
function RsaKeyGenParams() {
  
  /**
   * The length, in bits, of the RSA modulus.
   * 
   * @type {number}
   */
  this.modulusLength;
  
  /**
   * The RSA public exponent.
   * 
   * @type {Uint8Array}
   */
  this.publicExponent;
}
extend(Algorithm, RsaKeyGenParams);

/**
 * Initializes this algorithm with the values given as paramter.
 * 
 * @private
 * @param {object} alg The values which should be used to intitialize
 * the algorithm.
 * @returns {RsaKeyGenParams} The initialized RsaKeyGenParams
 */
RsaKeyGenParams.prototype.init = function(alg) {
  // Call parent init function
  RsaKeyGenParams._super.init.call(this, alg);
  
  if(!isNumber(alg.modulusLength)) {
    throw new TypeError(
            'RsaKeyGenParams: modulusLength: Missing or not a number');
  }
  this.modulusLength = alg.modulusLength;
  
  if(!alg.publicExponent || !isBigInteger(alg.publicExponent)) {
    throw new TypeError(
            'RsaKeyGenParams: publicExponent: Missing or not a BigInteger');
  }
  this.publicExponent = alg.publicExponent;
  return this;
};

/**
 * Creates a new RsaHashedKeyGenParams object.
 * @see {@link http://www.w3.org/TR/WebCryptoAPI/#dfn-RsaHashedKeyGenParams}
 * 
 * @private
 * @constructs RsaHashedKeyGenParams
 * @extends RsaKeyGenParams
 * @returns {RsaHashedKeyGenParams} Newly created RsaHashedKeyGenParams object.
 */
function RsaHashedKeyGenParams() {
  
  /**
   * The hash algorithm to use.
   * 
   * @type {HashAlgorithmIdentifier}
   */
  this.hash;
}
extend(RsaKeyGenParams, RsaHashedKeyGenParams);

/**
 * Initializes this algorithm with the values given as paramter.
 * 
 * @private
 * @param {object} alg The values which should be used to intitialize
 * the algorithm.
 * @returns {RsaKeyGenParams} The initialized RsaHashedKeyGenParams
 */
RsaHashedKeyGenParams.prototype.init = function(alg) {
  // Call parent init function
  RsaHashedKeyGenParams._super.init.call(this, alg);
  
  if(!isHashAlgorithmIdentifier(alg.hash)) {
    throw new TypeError(
      'RsaHashedKeyGenParms: hash: Missing or not a HashAlgorithmIdentifier');
  }
  this.hash = alg.hash;
  return this;
};

/**
 * Creates a new RsaHashedImportParams object.
 * @see {@link http://www.w3.org/TR/WebCryptoAPI/#dfn-RsaHashedImportParams}
 * 
 * @private
 * @constructs RsaHashedImportParams
 * @extends Algorithm
 * @returns {RsaHashedImportParams} Newly created RsaHashedImportParams object.
 */
function RsaHashedImportParams() {
  
  /**
   * The hash algorithm to use.
   * 
   * @type {HashAlgorithmIdentifier}
   */
  this.hash;
}
extend(Algorithm, RsaHashedImportParams);

/**
 * Initializes this algorithm with the values given as paramter.
 * 
 * @private
 * @param {object} alg The values which should be used to intitialize
 * the algorithm.
 * @returns {RsaKeyGenParams} The initialized RsaHashedImportParams
 */
RsaHashedImportParams.prototype.init = function(alg) {
  // Call parent init function
  RsaHashedImportParams._super.init.call(this, alg);
  
  if(!isHashAlgorithmIdentifier(alg.hash)) {
    throw new TypeError(
      'RsaHashedImportParams: hash: Missing or not a HashAlgorithmIdentifier');
  }
  this.hash = alg.hash;
  return this;
};

/**
 * Returns a newly generated RSA CryptoKeyPair, containing 
 * two newly generated keys.&lt;br />
 * The CryptoKeyPair is generated by using a fallback library.&lt;br />
 * RSA-OAEP: {@link http://www.w3.org/TR/WebCryptoAPI/#rsa-oaep-operations}
 * 
 * @private
 * @param {Object} normAlgo The key generation function to use.
 * @param {boolean} extractable Indicating if the key can be extracted from 
 * the CryptoKey object at a later stage.
 * @param {String[]} keyUsages Indicating what can be done with the newly 
 * generated key.
 * @returns {Object} A newly generated RSA CryptoKeyPair, containing 
 * two newly generated keys.
 */
function generateKey_RSA(normAlgo, extractable, keyUsages) {
    
    if(arrayContainsOther(
            keyUsages, ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'])) {
      throw new SyntaxError(
              'Cannot create a key using the specified key usages.');
    }
    
    try {
      // RSA.generateKey -> [ n, e, d, p, q, dp, dq, qi ]
      var asmKey = asmCrypto.RSA.generateKey(
              normAlgo.modulusLength, 
              normAlgo.publicExponent);
    } catch(err) {
      throw new OperationError(err);
    }
    
    var algorithm = {};
    algorithm.name = normAlgo.name;
    algorithm.modulusLength = normAlgo.modulusLength;
    algorithm.publicExponent = normAlgo.publicExponent;
    algorithm.hash = normAlgo.hash;
    
    var publicKey = new CryptoKey(
            'public', 
            true, 
            algorithm, 
            arrayIntersect(keyUsages, ['encrypt', 'wrapKey']),
            [asmKey[0], asmKey[1]]);
    
    var privateKey = new CryptoKey(
            'private',
            extractable,
            algorithm,
            arrayIntersect(keyUsages, ['decrypt', 'unwrapKey']),
            asmKey);


    var result = {
      publicKey: publicKey,
      privateKey: privateKey
    };
    return result;
}

/**
 * Returns the RSA key in the requested format.&lt;br />
 * RSA-OAEP: {@link http://www.w3.org/TR/WebCryptoAPI/#rsa-oaep-operations}&lt;br />
 * RSA-PSS: {@link http://www.w3.org/TR/WebCryptoAPI/#rsa-pss-operations}&lt;br />
 * RSASSA-PKCS1-v1_5: {@link http://www.w3.org/TR/WebCryptoAPI/#rsassa-pkcs1-operations}
 * 
 * @private
 * @param {string} format The data format in which the key has to be exported.
 * @param {CryptoKey} key The RSA CryptoKey to export.
 * @returns {*} The RSA key in the requested format.
 */
function exportKey_RSA(format, key) {
  var result;
  if(format === 'jwk') {
    var jwk = {};
    jwk.kty = "RSA";
    jwk.alg = algorithmToJWA(key.algorithm);
    jwk.n = bytesToBase64URL(key._handle[0]);
    jwk.e = bytesToBase64URL(key._handle[1]);
    if(key.type === "private") {
      jwk.d = bytesToBase64URL(key._handle[2]);
      jwk.p = bytesToBase64URL(key._handle[3]);
      jwk.q = bytesToBase64URL(key._handle[4]);
      jwk.dp = bytesToBase64URL(key._handle[5]);
      jwk.dq = bytesToBase64URL(key._handle[6]);
      jwk.qi = bytesToBase64URL(key._handle[7]);
    }
    jwk.key_ops = key.usages;
    jwk.ext = key.extractable;
    result = jwk;
  } else {
    throw new NotSupportedError("Export format '" + format 
            + "' not supported by algorithm '" + key.algorithm.name + "'");
  }
  return result;
};

/**
 * Returns the RSA CryptoKey generated from the data given in
 * parameters.&lt;br />
 * RSA-OAEP: {@link http://www.w3.org/TR/WebCryptoAPI/#rsa-oaep-operations}
 * 
 * @private
 * @param {string} format the data format of the key to imported. Possible
 * values are "raw" (usually a secret key), "pkcs8" (private key), 
 * "skpi" (usually a public key) and "jwk".
 * @param {BufferSource | Object} keyData The key in the specified format.
 * @param {Object} normAlgo The normalized cryptographic algorithm for use 
 * with the output key object.
 * @param {boolean} extractable indicating if the key can be extracted from the 
 * CryptoKey object at a later stage.
 * @param {string[]} usages Indicating what can be done with the key.
 * @returns {CryptoKey} The generated RSA CryptoKey.
 */
function importKey_RSA(format, keyData, normAlgo, extractable, usages) {
    
  var _handle,
      keyType;
  if(format === "jwk") {

    var jwk = keyData;
    if((jwk.d &amp;&amp; arrayContainsOther(usages, ['decrypt', 'unwrapKey'])) 
        || (!jwk.d &amp;&amp; arrayContainsOther(usages, ['encrypt', 'wrapKey']))) {
      throw new SyntaxError('Cannot create a key using the specified ' 
              + 'key usages.');
    }
    if(!keyData.kty) {
      throw new SyntaxError('The required JWK member "kty" was missing');
    }
    if(keyData.kty !== "RSA") {
      throw new DataError('The JWK "kty" member was not "RSA"');
    }
    if(jwk.use &amp;&amp; jwk.use !== 'enc') {
      throw new DataError('The JWK "use" member was not "enc"');
    }
    if(jwk.key_ops &amp;&amp; arrayContainsOther(usages, jwk.key_ops)) {
      throw new DataError('The JWK "key_ops" member does not contain all ' 
              + 'of the specified usages values.');
    }

    if(jwk.alg) {
      var jwkAlg = jwaToAlgorithm(jwk.alg);
      if(jwkAlg.name !== normAlgo.name || !jwkAlg.hash) {
        throw new DataError('The JWK "alg" member was inconsistent with ' 
                + 'that specified by the Web Crypto call');
      } else {
        var hash = jwkAlg.hash.name;
        var normHash = normalizeAlgorithm("digest", hash);
        if(normHash.name !== normAlgo.hash.name) {
          throw new DataError('The JWK "alg" member was inconsistent with ' 
                + 'that specified by the Web Crypto call');
        }
      }
    }

    if(jwk.d) {
      if(jwk.n &amp;&amp; jwk.e &amp;&amp; jwk.d &amp;&amp; jwk.p &amp;&amp; jwk.q &amp;&amp; jwk.dp &amp;&amp; jwk.dq 
              &amp;&amp; jwk.qi) {
        _handle = [
          base64URLToBytes(jwk.n),
          base64URLToBytes(jwk.e),
          base64URLToBytes(jwk.d),
          base64URLToBytes(jwk.p),
          base64URLToBytes(jwk.q),
          base64URLToBytes(jwk.dp),
          base64URLToBytes(jwk.dq),
          base64URLToBytes(jwk.qi)
        ];
        keyType = "private";
      } else {
        throw new DataError('JWK does not meet the requirements');
      }
    } else {
      if(jwk.n &amp;&amp; jwk.e) {
        _handle = [
          base64URLToBytes(jwk.n),
          base64URLToBytes(jwk.e)
        ];
        keyType = "public";
      } else {
        throw new DataError('JWK does not meet the requirements');
      }
    }
  } else {
    throw new NotSupportedError('Format "' + format 
            + '" not yet supported');
  }

  var algorithm = {};
  algorithm.name = normAlgo.name;
  algorithm.modulusLength = _handle[0].length * 8;
  algorithm.publicExponent = new Uint8Array(_handle[1]);
  algorithm.hash = normAlgo.hash;

  return new CryptoKey(keyType, false, algorithm, [], _handle);
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-webcrypto.html">webcrypto</a></li></ul><h3>Classes</h3><ul><li><a href="module-webcrypto.CryptoKey.html">CryptoKey</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-webcrypto.ext.html">ext</a></li><li><a href="module-webcrypto.ext.pbkdf2.html">pbkdf2</a></li><li><a href="module-webcrypto.ext.sha256.html">sha256</a></li><li><a href="module-webcrypto.subtle.html">subtle</a></li><li><a href="module-webcrypto.util.html">util</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Wed Jan 13 2016 15:35:34 GMT+0100 (Mitteleuropäische Zeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
